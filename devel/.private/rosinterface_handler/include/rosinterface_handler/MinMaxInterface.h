// *********************************************************
//
// File autogenerated for the rosinterface_handler package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>

#else

#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#include <rosinterface_handler/MinMaxConfig.h>
#pragma GCC diagnostic pop
#else
struct MinMaxConfig{};
#endif


namespace rosinterface_handler {

/// \brief Parameter struct generated by rosinterface_handler
struct MinMaxInterface {

  using Config = MinMaxConfig;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using Subscriber = message_filters::Subscriber<T>;
  template<typename T>
  using SubscriberPtr = std::shared_ptr<Subscriber<T>>;
#endif
#ifdef IF_HANDLER_DIAGNOSTICS_INCLUDED
  template<typename T>
  using DiagSubscriber = rosinterface_handler::DiagnosedSubscriber<T>;
  template<typename T>
  using DiagSubscriberPtr = std::shared_ptr<DiagSubscriber<T>>;
  template<typename T>
  using DiagPublisher = rosinterface_handler::DiagnosedPublisher<T>;
#endif

  MinMaxInterface(const ros::NodeHandle& private_node_handle)
  : globalNamespace_{"/"},
    publicNamespace_{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace_{private_node_handle.getNamespace() + "/"},
    nodeName_{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle_{private_node_handle} {}

  /// \brief Get values from parameter server
  ///
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosinterface_handler::getParam(privateNamespace_ + "int_param_w_minmax", int_param_w_minmax, int{3});
    success &= rosinterface_handler::getParam(privateNamespace_ + "double_param_w_minmax", double_param_w_minmax, double{3.1});
    success &= rosinterface_handler::getParam(privateNamespace_ + "vector_int_param_w_minmax", vector_int_param_w_minmax, std::vector<int>{-1,2,3});
    success &= rosinterface_handler::getParam(privateNamespace_ + "vector_double_param_w_minmax", vector_double_param_w_minmax, std::vector<double>{-1.1,1.2,2.3});
    success &= rosinterface_handler::getParam(privateNamespace_ + "map_param_w_minmax", map_param_w_minmax, std::map<std::string,double>{{"value3",2.2},{"value2",1.2},{"value1",-1.2}});



    rosinterface_handler::testMin<int>(privateNamespace_ + "int_param_w_minmax", int_param_w_minmax, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "int_param_w_minmax", int_param_w_minmax, 2);
    rosinterface_handler::testMin<double>(privateNamespace_ + "double_param_w_minmax", double_param_w_minmax, 0.0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "double_param_w_minmax", double_param_w_minmax, 2.0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "vector_int_param_w_minmax", vector_int_param_w_minmax, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "vector_int_param_w_minmax", vector_int_param_w_minmax, 2);
    rosinterface_handler::testMin<double>(privateNamespace_ + "vector_double_param_w_minmax", vector_double_param_w_minmax, 0.0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "vector_double_param_w_minmax", vector_double_param_w_minmax, 2.0);
    rosinterface_handler::testMin<std::string,double>(privateNamespace_ + "map_param_w_minmax", map_param_w_minmax, 0.0);
    rosinterface_handler::testMax<std::string,double>(privateNamespace_ + "map_param_w_minmax", map_param_w_minmax, 2.0);
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
    rosinterface_handler::setParam(privateNamespace_ + "int_param_w_minmax",int_param_w_minmax);
    rosinterface_handler::setParam(privateNamespace_ + "double_param_w_minmax",double_param_w_minmax);
    rosinterface_handler::setParam(privateNamespace_ + "vector_int_param_w_minmax",vector_int_param_w_minmax);
    rosinterface_handler::setParam(privateNamespace_ + "vector_double_param_w_minmax",vector_double_param_w_minmax);
    rosinterface_handler::setParam(privateNamespace_ + "map_param_w_minmax",map_param_w_minmax);
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND


#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const MinMaxInterface& p)
  {
    os << "[" << p.nodeName_ << "]\nNode " << p.nodeName_ << " has the following parameters:\n"
      << "	" << p.privateNamespace_ << "int_param_w_minmax:" << p.int_param_w_minmax << "\n"
      << "	" << p.privateNamespace_ << "double_param_w_minmax:" << p.double_param_w_minmax << "\n"
      << "	" << p.privateNamespace_ << "vector_int_param_w_minmax:" << p.vector_int_param_w_minmax << "\n"
      << "	" << p.privateNamespace_ << "vector_double_param_w_minmax:" << p.vector_double_param_w_minmax << "\n"
      << "	" << p.privateNamespace_ << "map_param_w_minmax:" << p.map_param_w_minmax << "\n"
;
    return os;
  }

  /// \brief get the node handle that the interface struct uses internally
  ros::NodeHandle getPrivateNodeHandle() {
      return privateNodeHandle_;
  }

  /// \brief returns the name of the node (works in nodelets, too)
  const std::string& nodeName() {
      return nodeName_;
  }
private:
  const std::string globalNamespace_;
  const std::string publicNamespace_;
  const std::string privateNamespace_;
  const std::string nodeName_;
  ros::NodeHandle privateNodeHandle_;

public:
  int int_param_w_minmax; /*!< An Integer parameter */
  double double_param_w_minmax; /*!< A double parameter */
  std::vector<int> vector_int_param_w_minmax; /*!< A vector of int parameter */
  std::vector<double> vector_double_param_w_minmax; /*!< A vector of double parameter */
  std::map<std::string,double> map_param_w_minmax; /*!< A map parameter */



private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName_ << "]\nThe following parameters do not have default values and need to be specified:\n"
    );
  }
};

} // namespace rosinterface_handler
